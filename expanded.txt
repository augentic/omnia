#![feature(prelude_import)]
//! # WASI WebSocket Service
//!
//! This module implements a runtime service for `wasi:websocket`
//! (<https://github.com/augentic/wasi-websocket>).
extern crate std;
#[prelude_import]
use std::prelude::rust_2024::*;
mod host {
    //! # WASI WebSocket Service
    //!
    //! This module implements a runtime server for websocket
    pub mod default_impl {
        //! Default implementation for wasi-websocket
        //!
        //! This implementation runs a real tungstenite WebSocket server that external
        //! clients can connect to. Incoming messages from WS clients are broadcast as
        //! events to the guest handler. Outbound events from the guest are sent to
        //! connected WS clients, optionally filtered by group.
        //!
        //! For production use, use a backend with proper WebSocket connection
        //! management and authentication.
        use std::any::Any;
        use std::collections::{HashMap, HashSet};
        use std::env;
        use std::net::SocketAddr;
        use std::sync::{Arc, Mutex, PoisonError};
        use std::time::Duration;
        use anyhow::Result;
        use futures::FutureExt;
        use futures_channel::mpsc;
        use futures_util::stream::TryStreamExt;
        use futures_util::{StreamExt, future, pin_mut};
        use qwasr::{Backend, FutureResult};
        use tokio::net::{TcpListener, TcpStream};
        use tokio::sync::broadcast::{self, Receiver, Sender};
        use tokio_stream::wrappers::BroadcastStream;
        use tokio_tungstenite::tungstenite::{Message, Utf8Bytes};
        use tokio_tungstenite::{WebSocketStream, accept_async};
        use tracing::instrument;
        use crate::host::WebSocketCtx;
        use crate::host::resource::{Event, EventProxy, Socket, Subscriptions};
        const DEF_WEBSOCKET_ADDR: &str = "0.0.0.0:80";
        /// Options used to connect to the WebSocket service.
        pub struct ConnectOptions;
        #[automatically_derived]
        impl ::core::fmt::Debug for ConnectOptions {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "ConnectOptions")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ConnectOptions {
            #[inline]
            fn clone(&self) -> ConnectOptions {
                ConnectOptions
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ConnectOptions {
            #[inline]
            fn default() -> ConnectOptions {
                ConnectOptions {}
            }
        }
        impl qwasr::FromEnv for ConnectOptions {
            fn from_env() -> Result<Self> {
                Ok(Self)
            }
        }
        /// Default implementation for `wasi:websocket`.
        pub struct WebSocketDefault {
            event_tx: Sender<EventProxy>,
            event_rx: Receiver<EventProxy>,
            connections: ConnectionMap,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for WebSocketDefault {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "WebSocketDefault",
                    "event_tx",
                    &self.event_tx,
                    "event_rx",
                    &self.event_rx,
                    "connections",
                    &&self.connections,
                )
            }
        }
        impl Clone for WebSocketDefault {
            fn clone(&self) -> Self {
                Self {
                    event_tx: self.event_tx.clone(),
                    event_rx: self.event_tx.subscribe(),
                    connections: Arc::clone(&self.connections),
                }
            }
        }
        impl Backend for WebSocketDefault {
            type ConnectOptions = ConnectOptions;
            #[allow(clippy::used_underscore_binding)]
            async fn connect_with(_options: Self::ConnectOptions) -> Result<Self> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "connect_with",
                                "qwasr_wasi_websocket::host::default_impl",
                                ::tracing::Level::INFO,
                                ::tracing_core::__macro_support::Option::Some(
                                    "crates/wasi-websocket/src/host/default_impl.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(67u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "qwasr_wasi_websocket::host::default_impl",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &[
                                        {
                                            const NAME: ::tracing::__macro_support::FieldName<
                                                { ::tracing::__macro_support::FieldName::len("_options") },
                                            > = ::tracing::__macro_support::FieldName::new("_options");
                                            NAME.as_str()
                                        },
                                    ],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                meta.fields()
                                    .value_set_all(
                                        &[
                                            (::tracing::__macro_support::Option::Some(
                                                &::tracing::field::debug(&_options)
                                                    as &dyn ::tracing::field::Value,
                                            )),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::empty_loop,
                        clippy::let_unit_value,
                        clippy::let_with_type_underscore,
                        clippy::needless_return,
                        clippy::unreachable
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<Self> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event crates/wasi-websocket/src/host/default_impl.rs:70",
                                        "qwasr_wasi_websocket::host::default_impl",
                                        ::tracing::Level::DEBUG,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "crates/wasi-websocket/src/host/default_impl.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(70u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "qwasr_wasi_websocket::host::default_impl",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::DEBUG
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set_all(
                                            &[
                                                (::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "initializing default WebSocket implementation",
                                                    ) as &dyn ::tracing::field::Value,
                                                )),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event crates/wasi-websocket/src/host/default_impl.rs:71",
                                        "qwasr_wasi_websocket::host::default_impl",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "crates/wasi-websocket/src/host/default_impl.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(71u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "qwasr_wasi_websocket::host::default_impl",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set_all(
                                            &[
                                                (::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Using default WebSocket implementation - suitable for development only",
                                                    ) as &dyn ::tracing::field::Value,
                                                )),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let (event_tx, event_rx) = broadcast::channel::<EventProxy>(256);
                        let connections = ConnectionMap::new(Mutex::new(HashMap::new()));
                        let websocket = Self {
                            event_tx,
                            event_rx,
                            connections,
                        };
                        let server = websocket.clone();
                        tokio::spawn(async move {
                            if let Err(e) = server.listen().await {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host/default_impl.rs:85",
                                                "qwasr_wasi_websocket::host::default_impl",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host/default_impl.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(85u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::default_impl",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("WebSocket server error: {0}", e)
                                                                as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        });
                        Ok(websocket)
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    ::tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
        }
        impl WebSocketCtx for WebSocketDefault {
            fn connect(&self) -> FutureResult<Arc<dyn Socket>> {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event crates/wasi-websocket/src/host/default_impl.rs:95",
                                "qwasr_wasi_websocket::host::default_impl",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "crates/wasi-websocket/src/host/default_impl.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(95u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "qwasr_wasi_websocket::host::default_impl",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("connecting WebSocket socket")
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let socket = self.clone();
                async move { Ok(Arc::new(socket) as Arc<dyn Socket>) }.boxed()
            }
            fn new_event(&self, data: Vec<u8>) -> Result<Arc<dyn Event>> {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event crates/wasi-websocket/src/host/default_impl.rs:101",
                                "qwasr_wasi_websocket::host::default_impl",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "crates/wasi-websocket/src/host/default_impl.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(101u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "qwasr_wasi_websocket::host::default_impl",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("creating new event")
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let event = InMemEvent { data, group: None };
                Ok(Arc::new(event) as Arc<dyn Event>)
            }
        }
        impl Socket for WebSocketDefault {
            fn subscribe(&self) -> FutureResult<Subscriptions> {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event crates/wasi-websocket/src/host/default_impl.rs:109",
                                "qwasr_wasi_websocket::host::default_impl",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "crates/wasi-websocket/src/host/default_impl.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(109u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "qwasr_wasi_websocket::host::default_impl",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("subscribing to WebSocket events")
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let stream = BroadcastStream::new(self.event_rx.resubscribe());
                async move {
                    let stream = stream
                        .filter_map(|res| async move {
                            match res {
                                Ok(event) => Some(event),
                                Err(e) => {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event crates/wasi-websocket/src/host/default_impl.rs:117",
                                                    "qwasr_wasi_websocket::host::default_impl",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "crates/wasi-websocket/src/host/default_impl.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(117u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "qwasr_wasi_websocket::host::default_impl",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &format_args!("broadcast lag: {0}", e)
                                                                    as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    None
                                }
                            }
                        });
                    Ok(Box::pin(stream) as Subscriptions)
                }
                    .boxed()
            }
            fn send(
                &self,
                event: EventProxy,
                groups: Option<Vec<String>>,
            ) -> FutureResult<()> {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event crates/wasi-websocket/src/host/default_impl.rs:128",
                                "qwasr_wasi_websocket::host::default_impl",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "crates/wasi-websocket/src/host/default_impl.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(128u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "qwasr_wasi_websocket::host::default_impl",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "sending event to WebSocket clients, groups: {0:?}",
                                                groups,
                                            ) as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let connections = Arc::clone(&self.connections);
                async move {
                    let data = event.data();
                    let text = String::from_utf8(data)
                        .unwrap_or_else(|e| {
                            String::from_utf8_lossy(e.as_bytes()).into_owned()
                        });
                    let msg = Message::Text(Utf8Bytes::from(text));
                    let senders: Vec<_> = {
                        let connections = connections
                            .lock()
                            .unwrap_or_else(PoisonError::into_inner);
                        groups
                            .as_ref()
                            .map_or_else(
                                || connections.values().map(|c| c.sender.clone()).collect(),
                                |groups| {
                                    connections
                                        .values()
                                        .filter(|c| groups.iter().any(|g| c.groups.contains(g)))
                                        .map(|c| c.sender.clone())
                                        .collect()
                                },
                            )
                    };
                    for mut sender in senders {
                        if sender.try_send(msg.clone()).is_err() {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event crates/wasi-websocket/src/host/default_impl.rs:154",
                                            "qwasr_wasi_websocket::host::default_impl",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "crates/wasi-websocket/src/host/default_impl.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(154u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "qwasr_wasi_websocket::host::default_impl",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set_all(
                                                &[
                                                    (::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "failed to send to peer, channel full or disconnected",
                                                        ) as &dyn ::tracing::field::Value,
                                                    )),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    Ok(())
                }
                    .boxed()
            }
        }
        impl WebSocketDefault {
            async fn listen(self) -> Result<()> {
                let addr = env::var("WEBSOCKET_ADDR")
                    .unwrap_or_else(|_| DEF_WEBSOCKET_ADDR.into());
                let listener = TcpListener::bind(&addr).await?;
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event crates/wasi-websocket/src/host/default_impl.rs:168",
                                "qwasr_wasi_websocket::host::default_impl",
                                ::tracing::Level::INFO,
                                ::tracing_core::__macro_support::Option::Some(
                                    "crates/wasi-websocket/src/host/default_impl.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(168u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "qwasr_wasi_websocket::host::default_impl",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "websocket server listening on: {0}",
                                                listener.local_addr()?,
                                            ) as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                loop {
                    let (stream, peer_addr) = match listener.accept().await {
                        Ok(conn) => conn,
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event crates/wasi-websocket/src/host/default_impl.rs:174",
                                            "qwasr_wasi_websocket::host::default_impl",
                                            ::tracing::Level::ERROR,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "crates/wasi-websocket/src/host/default_impl.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(174u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "qwasr_wasi_websocket::host::default_impl",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set_all(
                                                &[
                                                    (::tracing::__macro_support::Option::Some(
                                                        &format_args!("accept error: {0}", e)
                                                            as &dyn ::tracing::field::Value,
                                                    )),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            tokio::time::sleep(Duration::from_millis(100)).await;
                            continue;
                        }
                    };
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-websocket/src/host/default_impl.rs:179",
                                    "qwasr_wasi_websocket::host::default_impl",
                                    ::tracing::Level::INFO,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "crates/wasi-websocket/src/host/default_impl.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(179u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "qwasr_wasi_websocket::host::default_impl",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set_all(
                                        &[
                                            (::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "New WebSocket connection from: {0}",
                                                    peer_addr,
                                                ) as &dyn ::tracing::field::Value,
                                            )),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let server = self.clone();
                    tokio::spawn(async move {
                        if let Ok(ws_stream) = accept_async(stream).await {
                            server.handle_connect(ws_stream, peer_addr).await;
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event crates/wasi-websocket/src/host/default_impl.rs:186",
                                            "qwasr_wasi_websocket::host::default_impl",
                                            ::tracing::Level::ERROR,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "crates/wasi-websocket/src/host/default_impl.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(186u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "qwasr_wasi_websocket::host::default_impl",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set_all(
                                                &[
                                                    (::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "WebSocket handshake failed for {0}",
                                                            peer_addr,
                                                        ) as &dyn ::tracing::field::Value,
                                                    )),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    });
                }
            }
            async fn handle_connect(
                &self,
                ws_stream: WebSocketStream<TcpStream>,
                peer: SocketAddr,
            ) {
                let (tx, rx) = mpsc::channel(256);
                self.connections
                    .lock()
                    .unwrap_or_else(PoisonError::into_inner)
                    .insert(
                        peer,
                        Connection {
                            groups: HashSet::new(),
                            sender: tx,
                        },
                    );
                let (outgoing, incoming) = ws_stream.split();
                let broadcast_incoming = incoming
                    .try_for_each(|msg| {
                        match msg {
                            Message::Text(text) => {
                                if let Ok(json) = serde_json::from_str::<
                                    serde_json::Value,
                                >(&text)
                                    && json.get("type").and_then(|t| t.as_str())
                                        == Some("subscribe")
                                    && let Some(groups) = json
                                        .get("groups")
                                        .and_then(|g| g.as_array())
                                {
                                    let group_set: HashSet<String> = groups
                                        .iter()
                                        .filter_map(|g| g.as_str().map(String::from))
                                        .collect();
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event crates/wasi-websocket/src/host/default_impl.rs:217",
                                                    "qwasr_wasi_websocket::host::default_impl",
                                                    ::tracing::Level::INFO,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "crates/wasi-websocket/src/host/default_impl.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(217u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "qwasr_wasi_websocket::host::default_impl",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::INFO
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::INFO
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "peer {0} subscribing to groups: {1:?}",
                                                                    peer,
                                                                    group_set,
                                                                ) as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    if let Some(conn) = self
                                        .connections
                                        .lock()
                                        .unwrap_or_else(PoisonError::into_inner)
                                        .get_mut(&peer)
                                    {
                                        conn.groups = group_set;
                                    }
                                    return future::ok(());
                                }
                                let event = InMemEvent {
                                    data: text.as_bytes().to_vec(),
                                    group: None,
                                };
                                if self.event_tx.send(EventProxy(Arc::new(event))).is_err()
                                {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event crates/wasi-websocket/src/host/default_impl.rs:234",
                                                    "qwasr_wasi_websocket::host::default_impl",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "crates/wasi-websocket/src/host/default_impl.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(234u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "qwasr_wasi_websocket::host::default_impl",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &format_args!("no subscribers for incoming WebSocket event")
                                                                    as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                }
                            }
                            Message::Binary(data) => {
                                let event = InMemEvent {
                                    data: data.to_vec(),
                                    group: None,
                                };
                                if self.event_tx.send(EventProxy(Arc::new(event))).is_err()
                                {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event crates/wasi-websocket/src/host/default_impl.rs:243",
                                                    "qwasr_wasi_websocket::host::default_impl",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "crates/wasi-websocket/src/host/default_impl.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(243u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "qwasr_wasi_websocket::host::default_impl",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &format_args!("no subscribers for incoming WebSocket event")
                                                                    as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                }
                            }
                            Message::Close(frame) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host/default_impl.rs:247",
                                                "qwasr_wasi_websocket::host::default_impl",
                                                ::tracing::Level::INFO,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host/default_impl.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(247u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::default_impl",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "peer {0} sent close frame: {1:?}",
                                                                peer,
                                                                frame,
                                                            ) as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            _ => {}
                        }
                        future::ok(())
                    });
                let receive_from_host = rx.map(Ok).forward(outgoing);
                let mut broadcast_incoming = broadcast_incoming;
                #[allow(unused_mut)]
                let mut broadcast_incoming = unsafe {
                    ::pin_utils::core_reexport::pin::Pin::new_unchecked(
                        &mut broadcast_incoming,
                    )
                };
                let mut receive_from_host = receive_from_host;
                #[allow(unused_mut)]
                let mut receive_from_host = unsafe {
                    ::pin_utils::core_reexport::pin::Pin::new_unchecked(
                        &mut receive_from_host,
                    )
                };
                future::select(broadcast_incoming, receive_from_host).await;
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event crates/wasi-websocket/src/host/default_impl.rs:259",
                                "qwasr_wasi_websocket::host::default_impl",
                                ::tracing::Level::INFO,
                                ::tracing_core::__macro_support::Option::Some(
                                    "crates/wasi-websocket/src/host/default_impl.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(259u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "qwasr_wasi_websocket::host::default_impl",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("{0} disconnected", peer)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                self.connections
                    .lock()
                    .unwrap_or_else(PoisonError::into_inner)
                    .remove(&peer);
            }
        }
        type ConnectionMap = Arc<Mutex<HashMap<SocketAddr, Connection>>>;
        struct Connection {
            groups: HashSet<String>,
            sender: mpsc::Sender<Message>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Connection {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Connection",
                    "groups",
                    &self.groups,
                    "sender",
                    &&self.sender,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Connection {
            #[inline]
            fn clone(&self) -> Connection {
                Connection {
                    groups: ::core::clone::Clone::clone(&self.groups),
                    sender: ::core::clone::Clone::clone(&self.sender),
                }
            }
        }
        struct InMemEvent {
            data: Vec<u8>,
            group: Option<String>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for InMemEvent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "InMemEvent",
                    "data",
                    &self.data,
                    "group",
                    &&self.group,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for InMemEvent {
            #[inline]
            fn clone(&self) -> InMemEvent {
                InMemEvent {
                    data: ::core::clone::Clone::clone(&self.data),
                    group: ::core::clone::Clone::clone(&self.group),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for InMemEvent {
            #[inline]
            fn default() -> InMemEvent {
                InMemEvent {
                    data: ::core::default::Default::default(),
                    group: ::core::default::Default::default(),
                }
            }
        }
        impl Event for InMemEvent {
            fn group(&self) -> Option<String> {
                self.group.clone()
            }
            fn data(&self) -> Vec<u8> {
                self.data.clone()
            }
            fn as_any(&self) -> &dyn Any {
                self
            }
        }
    }
    mod client_impl {
        use wasmtime::component::{Accessor, Resource};
        use crate::host::generated::wasi::websocket::client::{Host, HostWithStore};
        use crate::host::generated::wasi::websocket::types::Group;
        use crate::host::resource::{EventProxy, SocketProxy};
        use crate::host::types_impl::{get_event, get_socket};
        use crate::host::{Result, WasiWebSocket, WasiWebSocketCtxView};
        impl HostWithStore for WasiWebSocket {
            async fn send<T>(
                accessor: &Accessor<T, Self>,
                s: Resource<SocketProxy>,
                event: Resource<EventProxy>,
                group: Option<Vec<Group>>,
            ) -> Result<()> {
                let socket = get_socket(accessor, &s)?;
                let evt = get_event(accessor, &event)?;
                socket.send(evt, group).await?;
                Ok(())
            }
        }
        impl Host for WasiWebSocketCtxView<'_> {}
    }
    mod resource {
        use std::any::Any;
        use std::fmt::Debug;
        use std::ops::{Deref, DerefMut};
        use std::pin::Pin;
        use std::sync::Arc;
        use futures::Stream;
        use qwasr::FutureResult;
        /// Stream of event proxies.
        pub type Subscriptions = Pin<Box<dyn Stream<Item = EventProxy> + Send>>;
        /// Providers implement the [`Socket`] trait to allow the host to interact with
        /// backend WebSocket resources.
        #[allow(unused_variables)]
        pub trait Socket: Debug + Send + Sync + 'static {
            /// Subscribe to incoming events from WebSocket clients.
            fn subscribe(&self) -> FutureResult<Subscriptions>;
            /// Send an event to connected WebSocket clients, optionally filtered by groups.
            fn send(
                &self,
                event: EventProxy,
                groups: Option<Vec<String>>,
            ) -> FutureResult<()>;
        }
        /// Proxy for a WebSocket socket.
        pub struct SocketProxy(pub Arc<dyn Socket>);
        #[automatically_derived]
        impl ::core::clone::Clone for SocketProxy {
            #[inline]
            fn clone(&self) -> SocketProxy {
                SocketProxy(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SocketProxy {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "SocketProxy",
                    &&self.0,
                )
            }
        }
        impl Deref for SocketProxy {
            type Target = Arc<dyn Socket>;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        /// Providers implement the [`Event`] trait to represent WebSocket events.
        pub trait Event: Debug + Send + Sync + 'static {
            /// The group this event was received on, if any.
            fn group(&self) -> Option<String>;
            /// The event data.
            fn data(&self) -> Vec<u8>;
            /// For downcasting support.
            fn as_any(&self) -> &dyn Any;
        }
        /// Proxy for a WebSocket event.
        pub struct EventProxy(pub Arc<dyn Event>);
        #[automatically_derived]
        impl ::core::clone::Clone for EventProxy {
            #[inline]
            fn clone(&self) -> EventProxy {
                EventProxy(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for EventProxy {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "EventProxy",
                    &&self.0,
                )
            }
        }
        impl Deref for EventProxy {
            type Target = Arc<dyn Event>;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl DerefMut for EventProxy {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
    }
    mod server {
        use std::env;
        use anyhow::{Context, Result, anyhow};
        use futures::StreamExt;
        use qwasr::State;
        use tracing::{Instrument, debug_span, instrument};
        use wasmtime::Store;
        use crate::host::WebSocketView;
        use crate::host::generated::Websocket;
        use crate::host::resource::{EventProxy, Subscriptions};
        pub async fn run<S>(state: &S) -> Result<()>
        where
            S: State,
            S::StoreCtx: WebSocketView,
        {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "websocket-server",
                            "qwasr_wasi_websocket::host::server",
                            ::tracing::Level::INFO,
                            ::tracing_core::__macro_support::Option::Some(
                                "crates/wasi-websocket/src/host/server.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(13u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "qwasr_wasi_websocket::host::server",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set_all(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::empty_loop,
                    clippy::let_unit_value,
                    clippy::let_with_type_underscore,
                    clippy::needless_return,
                    clippy::unreachable
                )]
                if false {
                    let __tracing_attr_fake_return: Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let component = env::var("COMPONENT")
                        .unwrap_or_else(|_| "unknown".into());
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-websocket/src/host/server.rs:20",
                                    "qwasr_wasi_websocket::host::server",
                                    ::tracing::Level::INFO,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "crates/wasi-websocket/src/host/server.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(20u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "qwasr_wasi_websocket::host::server",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set_all(
                                        &[
                                            (::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "starting websocket server for: {0}",
                                                    component,
                                                ) as &dyn ::tracing::field::Value,
                                            )),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let handler = Handler {
                        state: state.clone(),
                        component,
                    };
                    let mut stream = handler.subscriptions().await?;
                    while let Some(event) = stream.next().await {
                        let handler = handler.clone();
                        tokio::spawn(async move {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event crates/wasi-websocket/src/host/server.rs:31",
                                            "qwasr_wasi_websocket::host::server",
                                            ::tracing::Level::INFO,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "crates/wasi-websocket/src/host/server.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(31u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "qwasr_wasi_websocket::host::server",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[
                                                    {
                                                        const NAME: ::tracing::__macro_support::FieldName<
                                                            {
                                                                ::tracing::__macro_support::FieldName::len(
                                                                    "monotonic_counter.event_counter",
                                                                )
                                                            },
                                                        > = ::tracing::__macro_support::FieldName::new(
                                                            "monotonic_counter.event_counter",
                                                        );
                                                        NAME.as_str()
                                                    },
                                                    {
                                                        const NAME: ::tracing::__macro_support::FieldName<
                                                            { ::tracing::__macro_support::FieldName::len("service") },
                                                        > = ::tracing::__macro_support::FieldName::new("service");
                                                        NAME.as_str()
                                                    },
                                                ],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set_all(
                                                &[
                                                    (::tracing::__macro_support::Option::Some(
                                                        &1 as &dyn ::tracing::field::Value,
                                                    )),
                                                    (::tracing::__macro_support::Option::Some(
                                                        &::tracing::field::display(&handler.component)
                                                            as &dyn ::tracing::field::Value,
                                                    )),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            if let Err(e) = handler.handle(event.clone()).await {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host/server.rs:34",
                                                "qwasr_wasi_websocket::host::server",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host/server.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(34u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::server",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("issue processing event: {0}", e)
                                                                as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host/server.rs:35",
                                                "qwasr_wasi_websocket::host::server",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host/server.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(35u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::server",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                {
                                                                    ::tracing::__macro_support::FieldName::len(
                                                                        "monotonic_counter.processing_errors",
                                                                    )
                                                                },
                                                            > = ::tracing::__macro_support::FieldName::new(
                                                                "monotonic_counter.processing_errors",
                                                            );
                                                            NAME.as_str()
                                                        },
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("service") },
                                                            > = ::tracing::__macro_support::FieldName::new("service");
                                                            NAME.as_str()
                                                        },
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("error") },
                                                            > = ::tracing::__macro_support::FieldName::new("error");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &1 as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &::tracing::field::display(&handler.component)
                                                                as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &::tracing::field::display(&e)
                                                                as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        });
                    }
                    Ok(())
                }
            };
            if !__tracing_attr_span.is_disabled() {
                ::tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        struct Handler<S>
        where
            S: State,
            S::StoreCtx: WebSocketView,
        {
            state: S,
            component: String,
        }
        #[automatically_derived]
        impl<S: ::core::clone::Clone> ::core::clone::Clone for Handler<S>
        where
            S: State,
            S::StoreCtx: WebSocketView,
        {
            #[inline]
            fn clone(&self) -> Handler<S> {
                Handler {
                    state: ::core::clone::Clone::clone(&self.state),
                    component: ::core::clone::Clone::clone(&self.component),
                }
            }
        }
        impl<S> Handler<S>
        where
            S: State,
            S::StoreCtx: WebSocketView,
        {
            /// Forward event to the wasm guest.
            async fn handle(&self, event: EventProxy) -> Result<()> {
                let mut store_data = self.state.store();
                let event_res = store_data
                    .websocket()
                    .table
                    .push(event)
                    .map_err(|e| ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("failed to push event: {0}", e),
                        );
                        error
                    }))?;
                let instance_pre = self.state.instance_pre();
                let mut store = Store::new(instance_pre.engine(), store_data);
                let instance = instance_pre.instantiate_async(&mut store).await?;
                let websocket = Websocket::new(&mut store, &instance)?;
                store
                    .run_concurrent(async |store| {
                        let guest = websocket.wasi_websocket_handler();
                        guest
                            .call_handle(store, event_res)
                            .await
                            .map(|_| ())
                            .map_err(anyhow::Error::from)
                            .context("issue handling event")
                    })
                    .instrument({
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "websocket-handle",
                                    "qwasr_wasi_websocket::host::server",
                                    ::tracing::Level::DEBUG,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "crates/wasi-websocket/src/host/server.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(86u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "qwasr_wasi_websocket::host::server",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{ meta.fields().value_set_all(&[]) },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    })
                    .await?
            }
            /// Get subscriptions for incoming WebSocket events.
            async fn subscriptions(&self) -> Result<Subscriptions> {
                let instance_pre = self.state.instance_pre();
                let store_data = self.state.store();
                let mut store = Store::new(instance_pre.engine(), store_data);
                store
                    .run_concurrent(async |store| {
                        let socket = store
                            .with(|mut store| store.get().websocket().ctx.connect())
                            .await?;
                        socket.subscribe().await
                    })
                    .await?
            }
        }
    }
    mod types_impl {
        use wasmtime::component::{Access, Accessor, Resource};
        pub use crate::host::generated::wasi::websocket::types::{
            Error, Group, Host, HostEvent, HostEventWithStore, HostSocket,
            HostSocketWithStore,
        };
        use crate::host::resource::{EventProxy, SocketProxy};
        use crate::host::{Result, WasiWebSocket, WasiWebSocketCtxView};
        impl HostSocketWithStore for WasiWebSocket {
            async fn connect<T>(
                accessor: &Accessor<T, Self>,
                _name: String,
            ) -> Result<Resource<SocketProxy>> {
                let socket = accessor.with(|mut store| store.get().ctx.connect()).await?;
                let proxy = SocketProxy(socket);
                Ok(accessor.with(|mut store| store.get().table.push(proxy))?)
            }
            fn disconnect<T>(
                _: Access<'_, T, Self>,
                _: Resource<SocketProxy>,
            ) -> Result<()> {
                Ok(())
            }
            fn drop<T>(
                mut accessor: Access<'_, T, Self>,
                rep: Resource<SocketProxy>,
            ) -> wasmtime::Result<()> {
                Ok(accessor.get().table.delete(rep).map(|_| ())?)
            }
        }
        impl HostEventWithStore for WasiWebSocket {
            /// Create a new event with the given payload.
            fn new<T>(
                mut host: Access<'_, T, Self>,
                data: Vec<u8>,
            ) -> wasmtime::Result<Resource<EventProxy>> {
                let event = host
                    .get()
                    .ctx
                    .new_event(data)
                    .map_err(wasmtime::Error::from_anyhow)?;
                let proxy = EventProxy(event);
                Ok(host.get().table.push(proxy)?)
            }
            /// The group this event was received on, if any.
            fn group<T>(
                mut host: Access<'_, T, Self>,
                self_: Resource<EventProxy>,
            ) -> wasmtime::Result<Option<Group>> {
                let event = host.get().table.get(&self_)?;
                Ok(event.group())
            }
            /// The event data.
            fn data<T>(
                mut host: Access<'_, T, Self>,
                self_: Resource<EventProxy>,
            ) -> wasmtime::Result<Vec<u8>> {
                let event = host.get().table.get(&self_)?;
                Ok(event.data())
            }
            fn drop<T>(
                mut accessor: Access<'_, T, Self>,
                rep: Resource<EventProxy>,
            ) -> wasmtime::Result<()> {
                Ok(accessor.get().table.delete(rep).map(|_| ())?)
            }
        }
        impl Host for WasiWebSocketCtxView<'_> {
            fn convert_error(&mut self, err: Error) -> wasmtime::Result<Error> {
                Ok(err)
            }
        }
        impl HostSocket for WasiWebSocketCtxView<'_> {}
        impl HostEvent for WasiWebSocketCtxView<'_> {}
        pub fn get_socket<T>(
            accessor: &Accessor<T, WasiWebSocket>,
            self_: &Resource<SocketProxy>,
        ) -> Result<SocketProxy> {
            accessor
                .with(|mut store| {
                    let socket = store.get().table.get(self_)?;
                    Ok::<_, Error>(socket.clone())
                })
        }
        pub fn get_event<T>(
            accessor: &Accessor<T, WasiWebSocket>,
            self_: &Resource<EventProxy>,
        ) -> Result<EventProxy> {
            accessor
                .with(|mut store| {
                    let event = store.get().table.get(self_)?;
                    Ok::<_, Error>(event.clone())
                })
        }
    }
    mod generated {
        #![allow(missing_docs)]
        pub use wasi::websocket::types::Error;
        pub use crate::host::resource::{EventProxy, SocketProxy};
        type _TrappableError0 = Error;
        #[doc(hidden)]
        pub use EventProxy as __with_name0;
        #[doc(hidden)]
        pub use SocketProxy as __with_name1;
        /// Auto-generated bindings for a pre-instantiated version of a
        /// component which implements the world `websocket`.
        ///
        /// This structure is created through [`WebsocketPre::new`] which
        /// takes a [`InstancePre`](wasmtime::component::InstancePre) that
        /// has been created through a [`Linker`](wasmtime::component::Linker).
        ///
        /// For more information see [`Websocket`] as well.
        pub struct WebsocketPre<T: 'static> {
            instance_pre: wasmtime::component::InstancePre<T>,
            indices: WebsocketIndices,
        }
        impl<T: 'static> Clone for WebsocketPre<T> {
            fn clone(&self) -> Self {
                Self {
                    instance_pre: self.instance_pre.clone(),
                    indices: self.indices.clone(),
                }
            }
        }
        impl<_T: 'static> WebsocketPre<_T> {
            /// Creates a new copy of `WebsocketPre` bindings which can then
            /// be used to instantiate into a particular store.
            ///
            /// This method may fail if the component behind `instance_pre`
            /// does not have the required exports.
            pub fn new(
                instance_pre: wasmtime::component::InstancePre<_T>,
            ) -> wasmtime::Result<Self> {
                let indices = WebsocketIndices::new(&instance_pre)?;
                Ok(Self { instance_pre, indices })
            }
            pub fn engine(&self) -> &wasmtime::Engine {
                self.instance_pre.engine()
            }
            pub fn instance_pre(&self) -> &wasmtime::component::InstancePre<_T> {
                &self.instance_pre
            }
            /// Instantiates a new instance of [`Websocket`] within the
            /// `store` provided.
            ///
            /// This function will use `self` as the pre-instantiated
            /// instance to perform instantiation. Afterwards the preloaded
            /// indices in `self` are used to lookup all exports on the
            /// resulting instance.
            pub fn instantiate(
                &self,
                mut store: impl wasmtime::AsContextMut<Data = _T>,
            ) -> wasmtime::Result<Websocket> {
                let mut store = store.as_context_mut();
                let instance = self.instance_pre.instantiate(&mut store)?;
                self.indices.load(&mut store, &instance)
            }
        }
        impl<_T: Send + 'static> WebsocketPre<_T> {
            /// Same as [`Self::instantiate`], except with `async`.
            pub async fn instantiate_async(
                &self,
                mut store: impl wasmtime::AsContextMut<Data = _T>,
            ) -> wasmtime::Result<Websocket> {
                let mut store = store.as_context_mut();
                let instance = self.instance_pre.instantiate_async(&mut store).await?;
                self.indices.load(&mut store, &instance)
            }
        }
        /// Auto-generated bindings for index of the exports of
        /// `websocket`.
        ///
        /// This is an implementation detail of [`WebsocketPre`] and can
        /// be constructed if needed as well.
        ///
        /// For more information see [`Websocket`] as well.
        pub struct WebsocketIndices {
            interface0: exports::wasi::websocket::handler::GuestIndices,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for WebsocketIndices {
            #[inline]
            fn clone(&self) -> WebsocketIndices {
                WebsocketIndices {
                    interface0: ::core::clone::Clone::clone(&self.interface0),
                }
            }
        }
        /// Auto-generated bindings for an instance a component which
        /// implements the world `websocket`.
        ///
        /// This structure can be created through a number of means
        /// depending on your requirements and what you have on hand:
        ///
        /// * The most convenient way is to use
        ///   [`Websocket::instantiate`] which only needs a
        ///   [`Store`], [`Component`], and [`Linker`].
        ///
        /// * Alternatively you can create a [`WebsocketPre`] ahead of
        ///   time with a [`Component`] to front-load string lookups
        ///   of exports once instead of per-instantiation. This
        ///   method then uses [`WebsocketPre::instantiate`] to
        ///   create a [`Websocket`].
        ///
        /// * If you've instantiated the instance yourself already
        ///   then you can use [`Websocket::new`].
        ///
        /// These methods are all equivalent to one another and move
        /// around the tradeoff of what work is performed when.
        ///
        /// [`Store`]: wasmtime::Store
        /// [`Component`]: wasmtime::component::Component
        /// [`Linker`]: wasmtime::component::Linker
        pub struct Websocket {
            interface0: exports::wasi::websocket::handler::Guest,
        }
        const _: () = {
            impl WebsocketIndices {
                /// Creates a new copy of `WebsocketIndices` bindings which can then
                /// be used to instantiate into a particular store.
                ///
                /// This method may fail if the component does not have the
                /// required exports.
                pub fn new<_T>(
                    _instance_pre: &wasmtime::component::InstancePre<_T>,
                ) -> wasmtime::Result<Self> {
                    let _component = _instance_pre.component();
                    let _instance_type = _instance_pre.instance_type();
                    let interface0 = exports::wasi::websocket::handler::GuestIndices::new(
                        _instance_pre,
                    )?;
                    Ok(WebsocketIndices { interface0 })
                }
                /// Uses the indices stored in `self` to load an instance
                /// of [`Websocket`] from the instance provided.
                ///
                /// Note that at this time this method will additionally
                /// perform type-checks of all exports.
                pub fn load(
                    &self,
                    mut store: impl wasmtime::AsContextMut,
                    instance: &wasmtime::component::Instance,
                ) -> wasmtime::Result<Websocket> {
                    let _ = &mut store;
                    let _instance = instance;
                    let interface0 = self.interface0.load(&mut store, &_instance)?;
                    Ok(Websocket { interface0 })
                }
            }
            impl Websocket {
                /// Convenience wrapper around [`WebsocketPre::new`] and
                /// [`WebsocketPre::instantiate`].
                pub fn instantiate<_T>(
                    store: impl wasmtime::AsContextMut<Data = _T>,
                    component: &wasmtime::component::Component,
                    linker: &wasmtime::component::Linker<_T>,
                ) -> wasmtime::Result<Websocket> {
                    let pre = linker.instantiate_pre(component)?;
                    WebsocketPre::new(pre)?.instantiate(store)
                }
                /// Convenience wrapper around [`WebsocketIndices::new`] and
                /// [`WebsocketIndices::load`].
                pub fn new(
                    mut store: impl wasmtime::AsContextMut,
                    instance: &wasmtime::component::Instance,
                ) -> wasmtime::Result<Websocket> {
                    let indices = WebsocketIndices::new(&instance.instance_pre(&store))?;
                    indices.load(&mut store, instance)
                }
                /// Convenience wrapper around [`WebsocketPre::new`] and
                /// [`WebsocketPre::instantiate_async`].
                pub async fn instantiate_async<_T>(
                    store: impl wasmtime::AsContextMut<Data = _T>,
                    component: &wasmtime::component::Component,
                    linker: &wasmtime::component::Linker<_T>,
                ) -> wasmtime::Result<Websocket>
                where
                    _T: Send,
                {
                    let pre = linker.instantiate_pre(component)?;
                    WebsocketPre::new(pre)?.instantiate_async(store).await
                }
                pub fn add_to_linker<T, D>(
                    linker: &mut wasmtime::component::Linker<T>,
                    host_getter: fn(&mut T) -> D::Data<'_>,
                ) -> wasmtime::Result<()>
                where
                    D: wasi::websocket::types::HostWithStore
                        + wasi::websocket::client::HostWithStore + Send,
                    for<'a> D::Data<
                        'a,
                    >: wasi::websocket::types::Host + wasi::websocket::client::Host
                        + Send,
                    T: 'static + Send,
                {
                    wasi::websocket::types::add_to_linker::<T, D>(linker, host_getter)?;
                    wasi::websocket::client::add_to_linker::<T, D>(linker, host_getter)?;
                    Ok(())
                }
                pub fn wasi_websocket_handler(
                    &self,
                ) -> &exports::wasi::websocket::handler::Guest {
                    &self.interface0
                }
            }
        };
        pub mod wasi {
            pub mod websocket {
                #[allow(clippy::all)]
                pub mod types {
                    #[allow(unused_imports)]
                    use wasmtime::component::__internal::Box;
                    /// A connection to a websocket service.
                    pub use super::super::super::__with_name1 as Socket;
                    pub trait HostSocketWithStore: wasmtime::component::HasData + Send {
                        fn drop<T>(
                            accessor: wasmtime::component::Access<T, Self>,
                            rep: wasmtime::component::Resource<Socket>,
                        ) -> wasmtime::Result<()>;
                        fn connect<T: Send>(
                            accessor: &wasmtime::component::Accessor<T, Self>,
                            name: wasmtime::component::__internal::String,
                        ) -> impl ::core::future::Future<
                            Output = Result<
                                wasmtime::component::Resource<Socket>,
                                super::super::super::_TrappableError0,
                            >,
                        > + Send;
                        fn disconnect<T>(
                            host: wasmtime::component::Access<T, Self>,
                            self_: wasmtime::component::Resource<Socket>,
                        ) -> Result<(), super::super::super::_TrappableError0>;
                    }
                    pub trait HostSocket: Send {}
                    impl<_T: HostSocket + ?Sized + Send> HostSocket for &mut _T {}
                    /// A type alias for string to represent a websocket group
                    pub type Group = wasmtime::component::__internal::String;
                    const _: () = {
                        if !(8 == <Group as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 8 == <Group as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(4 == <Group as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 4 == <Group as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    /// A websocket event.
                    pub use super::super::super::__with_name0 as Event;
                    pub trait HostEventWithStore: wasmtime::component::HasData {
                        fn drop<T>(
                            accessor: wasmtime::component::Access<T, Self>,
                            rep: wasmtime::component::Resource<Event>,
                        ) -> wasmtime::Result<()>;
                        fn new<T>(
                            host: wasmtime::component::Access<T, Self>,
                            data: wasmtime::component::__internal::Vec<u8>,
                        ) -> wasmtime::Result<wasmtime::component::Resource<Event>>;
                        /// The group this event was received on, if any
                        fn group<T>(
                            host: wasmtime::component::Access<T, Self>,
                            self_: wasmtime::component::Resource<Event>,
                        ) -> wasmtime::Result<Option<Group>>;
                        /// The event message.
                        fn data<T>(
                            host: wasmtime::component::Access<T, Self>,
                            self_: wasmtime::component::Resource<Event>,
                        ) -> wasmtime::Result<wasmtime::component::__internal::Vec<u8>>;
                    }
                    pub trait HostEvent {}
                    impl<_T: HostEvent + ?Sized> HostEvent for &mut _T {}
                    /// Errors that can occur when using the websocket interface.
                    #[component(variant)]
                    pub enum Error {
                        /// The request or operation timed out.
                        #[component(name = "timeout")]
                        Timeout,
                        /// An error occurred with the connection.
                        #[component(name = "connection")]
                        Connection(wasmtime::component::__internal::String),
                        /// A permission error occurred.
                        #[component(name = "permission-denied")]
                        PermissionDenied(wasmtime::component::__internal::String),
                        /// A catch all for other types of errors
                        #[component(name = "other")]
                        Other(wasmtime::component::__internal::String),
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for Error {
                        #[inline]
                        fn clone(&self) -> Error {
                            match self {
                                Error::Timeout => Error::Timeout,
                                Error::Connection(__self_0) => {
                                    Error::Connection(::core::clone::Clone::clone(__self_0))
                                }
                                Error::PermissionDenied(__self_0) => {
                                    Error::PermissionDenied(
                                        ::core::clone::Clone::clone(__self_0),
                                    )
                                }
                                Error::Other(__self_0) => {
                                    Error::Other(::core::clone::Clone::clone(__self_0))
                                }
                            }
                        }
                    }
                    unsafe impl wasmtime::component::Lower for Error {
                        #[inline]
                        fn linear_lower_to_flat<T>(
                            &self,
                            cx: &mut wasmtime::component::__internal::LowerContext<
                                '_,
                                T,
                            >,
                            ty: wasmtime::component::__internal::InterfaceType,
                            dst: &mut core::mem::MaybeUninit<Self::Lower>,
                        ) -> wasmtime::Result<()> {
                            let ty = match ty {
                                wasmtime::component::__internal::InterfaceType::Variant(
                                    i,
                                ) => &cx.types[i],
                                _ => wasmtime::component::__internal::bad_type_info(),
                            };
                            match self {
                                Self::Timeout => {
                                    {
                                        #[allow(unused_unsafe, reason = "macro-generated code")]
                                        {
                                            unsafe {
                                                use ::wasmtime::MaybeUninitExt;
                                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).tag)
                                            }
                                        }
                                    }
                                        .write(wasmtime::ValRaw::u32(0u32));
                                    unsafe {
                                        wasmtime::component::__internal::lower_payload(
                                            {
                                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                                {
                                                    unsafe {
                                                        use ::wasmtime::MaybeUninitExt;
                                                        let m: &mut core::mem::MaybeUninit<_> = dst;
                                                        m.map(|p| &raw mut (*p).payload)
                                                    }
                                                }
                                            },
                                            |payload| {
                                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                                {
                                                    unsafe {
                                                        use ::wasmtime::MaybeUninitExt;
                                                        let m: &mut core::mem::MaybeUninit<_> = payload;
                                                        m.map(|p| &raw mut (*p).Timeout)
                                                    }
                                                }
                                            },
                                            |dst| Ok(()),
                                        )
                                    }
                                }
                                Self::Connection(value) => {
                                    {
                                        #[allow(unused_unsafe, reason = "macro-generated code")]
                                        {
                                            unsafe {
                                                use ::wasmtime::MaybeUninitExt;
                                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).tag)
                                            }
                                        }
                                    }
                                        .write(wasmtime::ValRaw::u32(1u32));
                                    unsafe {
                                        wasmtime::component::__internal::lower_payload(
                                            {
                                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                                {
                                                    unsafe {
                                                        use ::wasmtime::MaybeUninitExt;
                                                        let m: &mut core::mem::MaybeUninit<_> = dst;
                                                        m.map(|p| &raw mut (*p).payload)
                                                    }
                                                }
                                            },
                                            |payload| {
                                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                                {
                                                    unsafe {
                                                        use ::wasmtime::MaybeUninitExt;
                                                        let m: &mut core::mem::MaybeUninit<_> = payload;
                                                        m.map(|p| &raw mut (*p).Connection)
                                                    }
                                                }
                                            },
                                            |dst| {
                                                value
                                                    .linear_lower_to_flat(
                                                        cx,
                                                        ty
                                                            .cases[1usize]
                                                            .unwrap_or_else(
                                                                wasmtime::component::__internal::bad_type_info,
                                                            ),
                                                        dst,
                                                    )
                                            },
                                        )
                                    }
                                }
                                Self::PermissionDenied(value) => {
                                    {
                                        #[allow(unused_unsafe, reason = "macro-generated code")]
                                        {
                                            unsafe {
                                                use ::wasmtime::MaybeUninitExt;
                                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).tag)
                                            }
                                        }
                                    }
                                        .write(wasmtime::ValRaw::u32(2u32));
                                    unsafe {
                                        wasmtime::component::__internal::lower_payload(
                                            {
                                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                                {
                                                    unsafe {
                                                        use ::wasmtime::MaybeUninitExt;
                                                        let m: &mut core::mem::MaybeUninit<_> = dst;
                                                        m.map(|p| &raw mut (*p).payload)
                                                    }
                                                }
                                            },
                                            |payload| {
                                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                                {
                                                    unsafe {
                                                        use ::wasmtime::MaybeUninitExt;
                                                        let m: &mut core::mem::MaybeUninit<_> = payload;
                                                        m.map(|p| &raw mut (*p).PermissionDenied)
                                                    }
                                                }
                                            },
                                            |dst| {
                                                value
                                                    .linear_lower_to_flat(
                                                        cx,
                                                        ty
                                                            .cases[2usize]
                                                            .unwrap_or_else(
                                                                wasmtime::component::__internal::bad_type_info,
                                                            ),
                                                        dst,
                                                    )
                                            },
                                        )
                                    }
                                }
                                Self::Other(value) => {
                                    {
                                        #[allow(unused_unsafe, reason = "macro-generated code")]
                                        {
                                            unsafe {
                                                use ::wasmtime::MaybeUninitExt;
                                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).tag)
                                            }
                                        }
                                    }
                                        .write(wasmtime::ValRaw::u32(3u32));
                                    unsafe {
                                        wasmtime::component::__internal::lower_payload(
                                            {
                                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                                {
                                                    unsafe {
                                                        use ::wasmtime::MaybeUninitExt;
                                                        let m: &mut core::mem::MaybeUninit<_> = dst;
                                                        m.map(|p| &raw mut (*p).payload)
                                                    }
                                                }
                                            },
                                            |payload| {
                                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                                {
                                                    unsafe {
                                                        use ::wasmtime::MaybeUninitExt;
                                                        let m: &mut core::mem::MaybeUninit<_> = payload;
                                                        m.map(|p| &raw mut (*p).Other)
                                                    }
                                                }
                                            },
                                            |dst| {
                                                value
                                                    .linear_lower_to_flat(
                                                        cx,
                                                        ty
                                                            .cases[3usize]
                                                            .unwrap_or_else(
                                                                wasmtime::component::__internal::bad_type_info,
                                                            ),
                                                        dst,
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        }
                        #[inline]
                        fn linear_lower_to_memory<T>(
                            &self,
                            cx: &mut wasmtime::component::__internal::LowerContext<
                                '_,
                                T,
                            >,
                            ty: wasmtime::component::__internal::InterfaceType,
                            mut offset: usize,
                        ) -> wasmtime::Result<()> {
                            let ty = match ty {
                                wasmtime::component::__internal::InterfaceType::Variant(
                                    i,
                                ) => &cx.types[i],
                                _ => wasmtime::component::__internal::bad_type_info(),
                            };
                            if true {
                                if !(offset
                                    % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                        as usize) == 0)
                                {
                                    ::core::panicking::panic(
                                        "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                    )
                                }
                            }
                            match self {
                                Self::Timeout => {
                                    *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                    Ok(())
                                }
                                Self::Connection(value) => {
                                    *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                    value
                                        .linear_lower_to_memory(
                                            cx,
                                            ty
                                                .cases[1usize]
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            offset
                                                + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                        )
                                }
                                Self::PermissionDenied(value) => {
                                    *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                    value
                                        .linear_lower_to_memory(
                                            cx,
                                            ty
                                                .cases[2usize]
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            offset
                                                + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                        )
                                }
                                Self::Other(value) => {
                                    *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                    value
                                        .linear_lower_to_memory(
                                            cx,
                                            ty
                                                .cases[3usize]
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            offset
                                                + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                        )
                                }
                            }
                        }
                    }
                    unsafe impl wasmtime::component::Lift for Error {
                        #[inline]
                        fn linear_lift_from_flat(
                            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                            ty: wasmtime::component::__internal::InterfaceType,
                            src: &Self::Lower,
                        ) -> wasmtime::Result<Self> {
                            let ty = match ty {
                                wasmtime::component::__internal::InterfaceType::Variant(
                                    i,
                                ) => &cx.types[i],
                                _ => wasmtime::component::__internal::bad_type_info(),
                            };
                            Ok(
                                match src.tag.get_u32() {
                                    0u32 => Self::Timeout,
                                    1u32 => {
                                        Self::Connection(
                                            <wasmtime::component::__internal::String as wasmtime::component::Lift>::linear_lift_from_flat(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                unsafe { &src.payload.Connection },
                                            )?,
                                        )
                                    }
                                    2u32 => {
                                        Self::PermissionDenied(
                                            <wasmtime::component::__internal::String as wasmtime::component::Lift>::linear_lift_from_flat(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                unsafe { &src.payload.PermissionDenied },
                                            )?,
                                        )
                                    }
                                    3u32 => {
                                        Self::Other(
                                            <wasmtime::component::__internal::String as wasmtime::component::Lift>::linear_lift_from_flat(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                unsafe { &src.payload.Other },
                                            )?,
                                        )
                                    }
                                    discrim => {
                                        return ::wasmtime_internal_core::error::macros::Err(
                                            ::wasmtime_internal_core::error::Error::from_format_args(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            ),
                                        );
                                    }
                                },
                            )
                        }
                        #[inline]
                        fn linear_lift_from_memory(
                            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                            ty: wasmtime::component::__internal::InterfaceType,
                            bytes: &[u8],
                        ) -> wasmtime::Result<Self> {
                            let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                            if true {
                                if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                    ::core::panicking::panic(
                                        "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                    )
                                }
                            }
                            let discrim = bytes[0];
                            let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                            let payload = &bytes[payload_offset..];
                            let ty = match ty {
                                wasmtime::component::__internal::InterfaceType::Variant(
                                    i,
                                ) => &cx.types[i],
                                _ => wasmtime::component::__internal::bad_type_info(),
                            };
                            Ok(
                                match discrim {
                                    0u8 => Self::Timeout,
                                    1u8 => {
                                        Self::Connection(
                                            <wasmtime::component::__internal::String as wasmtime::component::Lift>::linear_lift_from_memory(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                &payload[..<wasmtime::component::__internal::String as wasmtime::component::ComponentType>::SIZE32],
                                            )?,
                                        )
                                    }
                                    2u8 => {
                                        Self::PermissionDenied(
                                            <wasmtime::component::__internal::String as wasmtime::component::Lift>::linear_lift_from_memory(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                &payload[..<wasmtime::component::__internal::String as wasmtime::component::ComponentType>::SIZE32],
                                            )?,
                                        )
                                    }
                                    3u8 => {
                                        Self::Other(
                                            <wasmtime::component::__internal::String as wasmtime::component::Lift>::linear_lift_from_memory(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                &payload[..<wasmtime::component::__internal::String as wasmtime::component::ComponentType>::SIZE32],
                                            )?,
                                        )
                                    }
                                    discrim => {
                                        return ::wasmtime_internal_core::error::macros::Err(
                                            ::wasmtime_internal_core::error::Error::from_format_args(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            ),
                                        );
                                    }
                                },
                            )
                        }
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[repr(C)]
                        pub struct LowerError<T1: Copy, T2: Copy, T3: Copy> {
                            tag: wasmtime::ValRaw,
                            payload: LowerPayloadError<T1, T2, T3>,
                        }
                        #[automatically_derived]
                        impl<
                            T1: ::core::clone::Clone + Copy,
                            T2: ::core::clone::Clone + Copy,
                            T3: ::core::clone::Clone + Copy,
                        > ::core::clone::Clone for LowerError<T1, T2, T3> {
                            #[inline]
                            fn clone(&self) -> LowerError<T1, T2, T3> {
                                LowerError {
                                    tag: ::core::clone::Clone::clone(&self.tag),
                                    payload: ::core::clone::Clone::clone(&self.payload),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<
                            T1: ::core::marker::Copy + Copy,
                            T2: ::core::marker::Copy + Copy,
                            T3: ::core::marker::Copy + Copy,
                        > ::core::marker::Copy for LowerError<T1, T2, T3> {}
                        #[doc(hidden)]
                        #[allow(non_snake_case)]
                        #[repr(C)]
                        union LowerPayloadError<T1: Copy, T2: Copy, T3: Copy> {
                            Timeout: [wasmtime::ValRaw; 0],
                            Connection: T1,
                            PermissionDenied: T2,
                            Other: T3,
                        }
                        #[automatically_derived]
                        #[doc(hidden)]
                        #[allow(non_snake_case)]
                        unsafe impl<
                            T1: ::core::marker::Copy + ::core::clone::TrivialClone
                                + Copy,
                            T2: ::core::marker::Copy + ::core::clone::TrivialClone
                                + Copy,
                            T3: ::core::marker::Copy + ::core::clone::TrivialClone + Copy,
                        > ::core::clone::TrivialClone for LowerPayloadError<T1, T2, T3> {}
                        #[automatically_derived]
                        #[allow(non_snake_case)]
                        impl<
                            T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                            T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                            T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        > ::core::clone::Clone for LowerPayloadError<T1, T2, T3> {
                            #[inline]
                            fn clone(&self) -> LowerPayloadError<T1, T2, T3> {
                                let _: ::core::clone::AssertParamIsCopy<Self>;
                                *self
                            }
                        }
                        #[automatically_derived]
                        #[allow(non_snake_case)]
                        impl<
                            T1: ::core::marker::Copy + Copy,
                            T2: ::core::marker::Copy + Copy,
                            T3: ::core::marker::Copy + Copy,
                        > ::core::marker::Copy for LowerPayloadError<T1, T2, T3> {}
                        unsafe impl wasmtime::component::ComponentType for Error {
                            type Lower = LowerError<
                                <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::Lower,
                                <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::Lower,
                                <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::Lower,
                            >;
                            #[inline]
                            fn typecheck(
                                ty: &wasmtime::component::__internal::InterfaceType,
                                types: &wasmtime::component::__internal::InstanceType<'_>,
                            ) -> wasmtime::Result<()> {
                                wasmtime::component::__internal::typecheck_variant(
                                    ty,
                                    types,
                                    &[
                                        ("timeout", None),
                                        (
                                            "connection",
                                            Some(
                                                <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::typecheck,
                                            ),
                                        ),
                                        (
                                            "permission-denied",
                                            Some(
                                                <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::typecheck,
                                            ),
                                        ),
                                        (
                                            "other",
                                            Some(
                                                <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::typecheck,
                                            ),
                                        ),
                                    ],
                                )
                            }
                            const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                                &[
                                    None,
                                    Some(
                                        <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::ABI,
                                    ),
                                    Some(
                                        <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::ABI,
                                    ),
                                    Some(
                                        <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::ABI,
                                    ),
                                ],
                            );
                        }
                        unsafe impl wasmtime::component::__internal::ComponentVariant
                        for Error {
                            const CASES: &'static [Option<
                                wasmtime::component::__internal::CanonicalAbiInfo,
                            >] = &[
                                None,
                                Some(
                                    <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::ABI,
                                ),
                            ];
                        }
                    };
                    impl core::fmt::Debug for Error {
                        fn fmt(
                            &self,
                            f: &mut core::fmt::Formatter<'_>,
                        ) -> core::fmt::Result {
                            match self {
                                Error::Timeout => f.debug_tuple("Error::Timeout").finish(),
                                Error::Connection(e) => {
                                    f.debug_tuple("Error::Connection").field(e).finish()
                                }
                                Error::PermissionDenied(e) => {
                                    f.debug_tuple("Error::PermissionDenied").field(e).finish()
                                }
                                Error::Other(e) => {
                                    f.debug_tuple("Error::Other").field(e).finish()
                                }
                            }
                        }
                    }
                    impl core::fmt::Display for Error {
                        fn fmt(
                            &self,
                            f: &mut core::fmt::Formatter<'_>,
                        ) -> core::fmt::Result {
                            f.write_fmt(format_args!("{0:?}", self))
                        }
                    }
                    impl core::error::Error for Error {}
                    const _: () = {
                        if !(12 == <Error as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 12 == <Error as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(4 == <Error as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 4 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub trait HostWithStore: wasmtime::component::HasData + HostSocketWithStore + HostEventWithStore + Send {}
                    impl<_T: ?Sized> HostWithStore for _T
                    where
                        _T: wasmtime::component::HasData + HostSocketWithStore
                            + HostEventWithStore + Send,
                    {}
                    pub trait Host: HostSocket + HostEvent + Send {
                        fn convert_error(
                            &mut self,
                            err: super::super::super::_TrappableError0,
                        ) -> wasmtime::Result<Error>;
                    }
                    impl<_T: Host + ?Sized + Send> Host for &mut _T {
                        fn convert_error(
                            &mut self,
                            err: super::super::super::_TrappableError0,
                        ) -> wasmtime::Result<Error> {
                            Host::convert_error(*self, err)
                        }
                    }
                    pub fn add_to_linker<T, D>(
                        linker: &mut wasmtime::component::Linker<T>,
                        host_getter: fn(&mut T) -> D::Data<'_>,
                    ) -> wasmtime::Result<()>
                    where
                        D: HostWithStore,
                        for<'a> D::Data<'a>: Host,
                        T: 'static + Send,
                    {
                        let mut inst = linker.instance("wasi:websocket/types@0.1.0")?;
                        inst.resource(
                            "socket",
                            wasmtime::component::ResourceType::host::<Socket>(),
                            move |mut store, rep| -> wasmtime::Result<()> {
                                let resource = wasmtime::component::Resource::new_own(rep);
                                HostSocketWithStore::drop(
                                    wasmtime::component::Access::new(store, host_getter),
                                    resource,
                                )
                            },
                        )?;
                        inst.resource(
                            "event",
                            wasmtime::component::ResourceType::host::<Event>(),
                            move |mut store, rep| -> wasmtime::Result<()> {
                                let resource = wasmtime::component::Resource::new_own(rep);
                                HostEventWithStore::drop(
                                    wasmtime::component::Access::new(store, host_getter),
                                    resource,
                                )
                            },
                        )?;
                        inst.func_wrap_concurrent(
                            "[static]socket.connect",
                            move |
                                caller: &wasmtime::component::Accessor<T>,
                                (arg0,): (wasmtime::component::__internal::String,)|
                            {
                                use tracing::Instrument;
                                let span = {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "wit-bindgen import",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("module") },
                                                            > = ::tracing::__macro_support::FieldName::new("module");
                                                            NAME.as_str()
                                                        },
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("function") },
                                                            > = ::tracing::__macro_support::FieldName::new("function");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::SPAN,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let mut interest = ::tracing::subscriber::Interest::never();
                                    if tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            interest = __CALLSITE.interest();
                                            !interest.is_never()
                                        }
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                    {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Span::new(
                                            meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                meta.fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"types" as &dyn ::tracing::field::Value,
                                                            )),
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"[static]socket.connect" as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            },
                                        )
                                    } else {
                                        let span = ::tracing::__macro_support::__disabled_span(
                                            __CALLSITE.metadata(),
                                        );
                                        {};
                                        span
                                    }
                                };
                                wasmtime::component::__internal::Box::pin(
                                    async move {
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event crates/wasi-websocket/src/host.rs:18",
                                                        "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                        tracing::Level::TRACE,
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "crates/wasi-websocket/src/host.rs",
                                                        ),
                                                        ::tracing_core::__macro_support::Option::Some(18u32),
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                        ),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &[
                                                                "message",
                                                                {
                                                                    const NAME: ::tracing::__macro_support::FieldName<
                                                                        { ::tracing::__macro_support::FieldName::len("name") },
                                                                    > = ::tracing::__macro_support::FieldName::new("name");
                                                                    NAME.as_str()
                                                                },
                                                            ],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = tracing::Level::TRACE
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && tracing::Level::TRACE
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("call") as &dyn ::tracing::field::Value,
                                                                )),
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &tracing::field::debug(&arg0)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                        let host = &caller.with_getter(host_getter);
                                        let r = <D as HostSocketWithStore>::connect(host, arg0)
                                            .await;
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event crates/wasi-websocket/src/host.rs:18",
                                                        "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                        tracing::Level::TRACE,
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "crates/wasi-websocket/src/host.rs",
                                                        ),
                                                        ::tracing_core::__macro_support::Option::Some(18u32),
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                        ),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &[
                                                                "message",
                                                                {
                                                                    const NAME: ::tracing::__macro_support::FieldName<
                                                                        { ::tracing::__macro_support::FieldName::len("result") },
                                                                    > = ::tracing::__macro_support::FieldName::new("result");
                                                                    NAME.as_str()
                                                                },
                                                            ],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = tracing::Level::TRACE
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && tracing::Level::TRACE
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("return") as &dyn ::tracing::field::Value,
                                                                )),
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &tracing::field::debug(&r) as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                        Ok((
                                            match r {
                                                Ok(a) => Ok(a),
                                                Err(e) => {
                                                    Err(
                                                        caller
                                                            .with(|mut host| Host::convert_error(
                                                                &mut host_getter(host.get()),
                                                                e,
                                                            ))?,
                                                    )
                                                }
                                            },
                                        ))
                                    }
                                        .instrument(span),
                                )
                            },
                        )?;
                        inst.func_wrap(
                            "[method]socket.disconnect",
                            move |
                                mut caller: wasmtime::StoreContextMut<'_, T>,
                                (arg0,): (wasmtime::component::Resource<Socket>,)|
                            {
                                let span = {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "wit-bindgen import",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("module") },
                                                            > = ::tracing::__macro_support::FieldName::new("module");
                                                            NAME.as_str()
                                                        },
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("function") },
                                                            > = ::tracing::__macro_support::FieldName::new("function");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::SPAN,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let mut interest = ::tracing::subscriber::Interest::never();
                                    if tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            interest = __CALLSITE.interest();
                                            !interest.is_never()
                                        }
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                    {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Span::new(
                                            meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                meta.fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"types" as &dyn ::tracing::field::Value,
                                                            )),
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"[method]socket.disconnect" as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            },
                                        )
                                    } else {
                                        let span = ::tracing::__macro_support::__disabled_span(
                                            __CALLSITE.metadata(),
                                        );
                                        {};
                                        span
                                    }
                                };
                                let _enter = span.enter();
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host.rs:18",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        "message",
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("self_") },
                                                            > = ::tracing::__macro_support::FieldName::new("self_");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("call") as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &tracing::field::debug(&arg0)
                                                                as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let access_cx = wasmtime::AsContextMut::as_context_mut(
                                    &mut caller,
                                );
                                let host = wasmtime::component::Access::new(
                                    access_cx,
                                    host_getter,
                                );
                                let r = <D as HostSocketWithStore>::disconnect(host, arg0);
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host.rs:18",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        "message",
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("result") },
                                                            > = ::tracing::__macro_support::FieldName::new("result");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("return") as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &tracing::field::debug(&r) as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                Ok((
                                    match r {
                                        Ok(a) => Ok(a),
                                        Err(e) => {
                                            Err(
                                                Host::convert_error(&mut host_getter(caller.data_mut()), e)?,
                                            )
                                        }
                                    },
                                ))
                            },
                        )?;
                        inst.func_wrap(
                            "[constructor]event",
                            move |
                                mut caller: wasmtime::StoreContextMut<'_, T>,
                                (arg0,): (wasmtime::component::__internal::Vec<u8>,)|
                            {
                                let span = {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "wit-bindgen import",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("module") },
                                                            > = ::tracing::__macro_support::FieldName::new("module");
                                                            NAME.as_str()
                                                        },
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("function") },
                                                            > = ::tracing::__macro_support::FieldName::new("function");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::SPAN,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let mut interest = ::tracing::subscriber::Interest::never();
                                    if tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            interest = __CALLSITE.interest();
                                            !interest.is_never()
                                        }
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                    {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Span::new(
                                            meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                meta.fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"types" as &dyn ::tracing::field::Value,
                                                            )),
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"[constructor]event" as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            },
                                        )
                                    } else {
                                        let span = ::tracing::__macro_support::__disabled_span(
                                            __CALLSITE.metadata(),
                                        );
                                        {};
                                        span
                                    }
                                };
                                let _enter = span.enter();
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host.rs:18",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        "message",
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("data") },
                                                            > = ::tracing::__macro_support::FieldName::new("data");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("call") as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &tracing::field::debug("...")
                                                                as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let access_cx = wasmtime::AsContextMut::as_context_mut(
                                    &mut caller,
                                );
                                let host = wasmtime::component::Access::new(
                                    access_cx,
                                    host_getter,
                                );
                                let r = <D as HostEventWithStore>::new(host, arg0);
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host.rs:18",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        "message",
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("result") },
                                                            > = ::tracing::__macro_support::FieldName::new("result");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("return") as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &tracing::field::debug(&r) as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                Ok((r?,))
                            },
                        )?;
                        inst.func_wrap(
                            "[method]event.group",
                            move |
                                mut caller: wasmtime::StoreContextMut<'_, T>,
                                (arg0,): (wasmtime::component::Resource<Event>,)|
                            {
                                let span = {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "wit-bindgen import",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("module") },
                                                            > = ::tracing::__macro_support::FieldName::new("module");
                                                            NAME.as_str()
                                                        },
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("function") },
                                                            > = ::tracing::__macro_support::FieldName::new("function");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::SPAN,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let mut interest = ::tracing::subscriber::Interest::never();
                                    if tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            interest = __CALLSITE.interest();
                                            !interest.is_never()
                                        }
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                    {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Span::new(
                                            meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                meta.fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"types" as &dyn ::tracing::field::Value,
                                                            )),
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"[method]event.group" as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            },
                                        )
                                    } else {
                                        let span = ::tracing::__macro_support::__disabled_span(
                                            __CALLSITE.metadata(),
                                        );
                                        {};
                                        span
                                    }
                                };
                                let _enter = span.enter();
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host.rs:18",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        "message",
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("self_") },
                                                            > = ::tracing::__macro_support::FieldName::new("self_");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("call") as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &tracing::field::debug(&arg0)
                                                                as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let access_cx = wasmtime::AsContextMut::as_context_mut(
                                    &mut caller,
                                );
                                let host = wasmtime::component::Access::new(
                                    access_cx,
                                    host_getter,
                                );
                                let r = <D as HostEventWithStore>::group(host, arg0);
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host.rs:18",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        "message",
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("result") },
                                                            > = ::tracing::__macro_support::FieldName::new("result");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("return") as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &tracing::field::debug(&r) as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                Ok((r?,))
                            },
                        )?;
                        inst.func_wrap(
                            "[method]event.data",
                            move |
                                mut caller: wasmtime::StoreContextMut<'_, T>,
                                (arg0,): (wasmtime::component::Resource<Event>,)|
                            {
                                let span = {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "wit-bindgen import",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("module") },
                                                            > = ::tracing::__macro_support::FieldName::new("module");
                                                            NAME.as_str()
                                                        },
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("function") },
                                                            > = ::tracing::__macro_support::FieldName::new("function");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::SPAN,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let mut interest = ::tracing::subscriber::Interest::never();
                                    if tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            interest = __CALLSITE.interest();
                                            !interest.is_never()
                                        }
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                    {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Span::new(
                                            meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                meta.fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"types" as &dyn ::tracing::field::Value,
                                                            )),
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"[method]event.data" as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            },
                                        )
                                    } else {
                                        let span = ::tracing::__macro_support::__disabled_span(
                                            __CALLSITE.metadata(),
                                        );
                                        {};
                                        span
                                    }
                                };
                                let _enter = span.enter();
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host.rs:18",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        "message",
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("self_") },
                                                            > = ::tracing::__macro_support::FieldName::new("self_");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("call") as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &tracing::field::debug(&arg0)
                                                                as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let access_cx = wasmtime::AsContextMut::as_context_mut(
                                    &mut caller,
                                );
                                let host = wasmtime::component::Access::new(
                                    access_cx,
                                    host_getter,
                                );
                                let r = <D as HostEventWithStore>::data(host, arg0);
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event crates/wasi-websocket/src/host.rs:18",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::types",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        "message",
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("result") },
                                                            > = ::tracing::__macro_support::FieldName::new("result");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set_all(
                                                    &[
                                                        (::tracing::__macro_support::Option::Some(
                                                            &format_args!("return") as &dyn ::tracing::field::Value,
                                                        )),
                                                        (::tracing::__macro_support::Option::Some(
                                                            &tracing::field::debug("...")
                                                                as &dyn ::tracing::field::Value,
                                                        )),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                Ok((r?,))
                            },
                        )?;
                        Ok(())
                    }
                }
                #[allow(clippy::all)]
                pub mod client {
                    #[allow(unused_imports)]
                    use wasmtime::component::__internal::Box;
                    pub type Error = super::super::super::wasi::websocket::types::Error;
                    const _: () = {
                        if !(12 == <Error as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 12 == <Error as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(4 == <Error as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 4 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub type Event = super::super::super::wasi::websocket::types::Event;
                    pub type Socket = super::super::super::wasi::websocket::types::Socket;
                    pub type Group = super::super::super::wasi::websocket::types::Group;
                    const _: () = {
                        if !(8 == <Group as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 8 == <Group as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(4 == <Group as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 4 == <Group as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub trait HostWithStore: wasmtime::component::HasData + Send {
                        /// Sends the event using the given socket.
                        fn send<T: Send>(
                            accessor: &wasmtime::component::Accessor<T, Self>,
                            s: wasmtime::component::Resource<Socket>,
                            event: wasmtime::component::Resource<Event>,
                            group: Option<wasmtime::component::__internal::Vec<Group>>,
                        ) -> impl ::core::future::Future<
                            Output = Result<(), super::super::super::_TrappableError0>,
                        > + Send;
                    }
                    pub trait Host: Send {}
                    impl<_T: Host + ?Sized + Send> Host for &mut _T {}
                    pub fn add_to_linker<T, D>(
                        linker: &mut wasmtime::component::Linker<T>,
                        host_getter: fn(&mut T) -> D::Data<'_>,
                    ) -> wasmtime::Result<()>
                    where
                        D: HostWithStore,
                        for<'a> D::Data<
                            'a,
                        >: Host + super::super::super::wasi::websocket::types::Host,
                        T: 'static + Send,
                    {
                        let mut inst = linker.instance("wasi:websocket/client@0.1.0")?;
                        inst.func_wrap_concurrent(
                            "send",
                            move |
                                caller: &wasmtime::component::Accessor<T>,
                                (
                                    arg0,
                                    arg1,
                                    arg2,
                                ): (
                                    wasmtime::component::Resource<Socket>,
                                    wasmtime::component::Resource<Event>,
                                    Option<wasmtime::component::__internal::Vec<Group>>,
                                )|
                            {
                                use tracing::Instrument;
                                let span = {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "wit-bindgen import",
                                                "qwasr_wasi_websocket::host::generated::wasi::websocket::client",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::wasi::websocket::client",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("module") },
                                                            > = ::tracing::__macro_support::FieldName::new("module");
                                                            NAME.as_str()
                                                        },
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("function") },
                                                            > = ::tracing::__macro_support::FieldName::new("function");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::SPAN,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let mut interest = ::tracing::subscriber::Interest::never();
                                    if tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            interest = __CALLSITE.interest();
                                            !interest.is_never()
                                        }
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                    {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Span::new(
                                            meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                meta.fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"client" as &dyn ::tracing::field::Value,
                                                            )),
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"send" as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            },
                                        )
                                    } else {
                                        let span = ::tracing::__macro_support::__disabled_span(
                                            __CALLSITE.metadata(),
                                        );
                                        {};
                                        span
                                    }
                                };
                                wasmtime::component::__internal::Box::pin(
                                    async move {
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event crates/wasi-websocket/src/host.rs:18",
                                                        "qwasr_wasi_websocket::host::generated::wasi::websocket::client",
                                                        tracing::Level::TRACE,
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "crates/wasi-websocket/src/host.rs",
                                                        ),
                                                        ::tracing_core::__macro_support::Option::Some(18u32),
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "qwasr_wasi_websocket::host::generated::wasi::websocket::client",
                                                        ),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &[
                                                                "message",
                                                                {
                                                                    const NAME: ::tracing::__macro_support::FieldName<
                                                                        { ::tracing::__macro_support::FieldName::len("s") },
                                                                    > = ::tracing::__macro_support::FieldName::new("s");
                                                                    NAME.as_str()
                                                                },
                                                                {
                                                                    const NAME: ::tracing::__macro_support::FieldName<
                                                                        { ::tracing::__macro_support::FieldName::len("event") },
                                                                    > = ::tracing::__macro_support::FieldName::new("event");
                                                                    NAME.as_str()
                                                                },
                                                                {
                                                                    const NAME: ::tracing::__macro_support::FieldName<
                                                                        { ::tracing::__macro_support::FieldName::len("group") },
                                                                    > = ::tracing::__macro_support::FieldName::new("group");
                                                                    NAME.as_str()
                                                                },
                                                            ],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = tracing::Level::TRACE
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && tracing::Level::TRACE
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("call") as &dyn ::tracing::field::Value,
                                                                )),
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &tracing::field::debug(&arg0)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &tracing::field::debug(&arg1)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &tracing::field::debug("...")
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                        let host = &caller.with_getter(host_getter);
                                        let r = <D as HostWithStore>::send(host, arg0, arg1, arg2)
                                            .await;
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event crates/wasi-websocket/src/host.rs:18",
                                                        "qwasr_wasi_websocket::host::generated::wasi::websocket::client",
                                                        tracing::Level::TRACE,
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "crates/wasi-websocket/src/host.rs",
                                                        ),
                                                        ::tracing_core::__macro_support::Option::Some(18u32),
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "qwasr_wasi_websocket::host::generated::wasi::websocket::client",
                                                        ),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &[
                                                                "message",
                                                                {
                                                                    const NAME: ::tracing::__macro_support::FieldName<
                                                                        { ::tracing::__macro_support::FieldName::len("result") },
                                                                    > = ::tracing::__macro_support::FieldName::new("result");
                                                                    NAME.as_str()
                                                                },
                                                            ],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = tracing::Level::TRACE
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && tracing::Level::TRACE
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("return") as &dyn ::tracing::field::Value,
                                                                )),
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &tracing::field::debug(&r) as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                        Ok((
                                            match r {
                                                Ok(a) => Ok(a),
                                                Err(e) => {
                                                    Err(
                                                        caller
                                                            .with(|mut host| super::super::super::wasi::websocket::types::Host::convert_error(
                                                                &mut host_getter(host.get()),
                                                                e,
                                                            ))?,
                                                    )
                                                }
                                            },
                                        ))
                                    }
                                        .instrument(span),
                                )
                            },
                        )?;
                        Ok(())
                    }
                }
            }
        }
        pub mod exports {
            pub mod wasi {
                pub mod websocket {
                    #[allow(clippy::all)]
                    pub mod handler {
                        #[allow(unused_imports)]
                        use wasmtime::component::__internal::Box;
                        pub type Event = super::super::super::super::wasi::websocket::types::Event;
                        pub type Error = super::super::super::super::wasi::websocket::types::Error;
                        const _: () = {
                            if !(12
                                == <Error as wasmtime::component::ComponentType>::SIZE32)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: 12 == <Error as wasmtime::component::ComponentType>::SIZE32",
                                )
                            }
                            if !(4
                                == <Error as wasmtime::component::ComponentType>::ALIGN32)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: 4 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                                )
                            }
                        };
                        pub struct Guest {
                            handle: wasmtime::component::Func,
                        }
                        #[automatically_derived]
                        impl ::core::clone::Clone for Guest {
                            #[inline]
                            fn clone(&self) -> Guest {
                                Guest {
                                    handle: ::core::clone::Clone::clone(&self.handle),
                                }
                            }
                        }
                        pub struct GuestIndices {
                            handle: wasmtime::component::ComponentExportIndex,
                        }
                        #[automatically_derived]
                        impl ::core::clone::Clone for GuestIndices {
                            #[inline]
                            fn clone(&self) -> GuestIndices {
                                GuestIndices {
                                    handle: ::core::clone::Clone::clone(&self.handle),
                                }
                            }
                        }
                        impl GuestIndices {
                            /// Constructor for [`GuestIndices`] which takes a
                            /// [`Component`](wasmtime::component::Component) as input and can be executed
                            /// before instantiation.
                            ///
                            /// This constructor can be used to front-load string lookups to find exports
                            /// within a component.
                            pub fn new<_T>(
                                _instance_pre: &wasmtime::component::InstancePre<_T>,
                            ) -> wasmtime::Result<GuestIndices> {
                                let instance = _instance_pre
                                    .component()
                                    .get_export_index(None, "wasi:websocket/handler@0.1.0")
                                    .ok_or_else(|| ::wasmtime_internal_core::error::Error::from_format_args(
                                        format_args!(
                                            "no exported instance named `wasi:websocket/handler@0.1.0`",
                                        ),
                                    ))?;
                                let mut lookup = move |name| {
                                    _instance_pre
                                        .component()
                                        .get_export_index(Some(&instance), name)
                                        .ok_or_else(|| {
                                            ::wasmtime_internal_core::error::Error::from_format_args(
                                                format_args!(
                                                    "instance export `wasi:websocket/handler@0.1.0` does not have export `{0}`",
                                                    name,
                                                ),
                                            )
                                        })
                                };
                                let _ = &mut lookup;
                                let handle = lookup("handle")?;
                                Ok(GuestIndices { handle })
                            }
                            pub fn load(
                                &self,
                                mut store: impl wasmtime::AsContextMut,
                                instance: &wasmtime::component::Instance,
                            ) -> wasmtime::Result<Guest> {
                                let _instance = instance;
                                let _instance_pre = _instance.instance_pre(&store);
                                let _instance_type = _instance_pre.instance_type();
                                let mut store = store.as_context_mut();
                                let _ = &mut store;
                                let handle = *_instance
                                    .get_typed_func::<
                                        (wasmtime::component::Resource<Event>,),
                                        (Result<(), Error>,),
                                    >(&mut store, &self.handle)?
                                    .func();
                                Ok(Guest { handle })
                            }
                        }
                        impl Guest {
                            /// Whenever this guest receives a message in one of the subscribed topics, the message is
                            /// sent to this handler. The guest is responsible for matching on the group and handling the
                            /// message accordingly. Implementors (such as hosts) calling this interface should make their
                            /// own decisions on how to handle errors returned from this function.
                            pub async fn call_handle<_T, _D>(
                                &self,
                                accessor: &wasmtime::component::Accessor<_T, _D>,
                                arg0: wasmtime::component::Resource<Event>,
                            ) -> wasmtime::Result<Result<(), Error>>
                            where
                                _T: Send,
                                _D: wasmtime::component::HasData,
                            {
                                use tracing::Instrument;
                                let span = {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "wit-bindgen export",
                                                "qwasr_wasi_websocket::host::generated::exports::wasi::websocket::handler",
                                                tracing::Level::TRACE,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "crates/wasi-websocket/src/host.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(18u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "qwasr_wasi_websocket::host::generated::exports::wasi::websocket::handler",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &[
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("module") },
                                                            > = ::tracing::__macro_support::FieldName::new("module");
                                                            NAME.as_str()
                                                        },
                                                        {
                                                            const NAME: ::tracing::__macro_support::FieldName<
                                                                { ::tracing::__macro_support::FieldName::len("function") },
                                                            > = ::tracing::__macro_support::FieldName::new("function");
                                                            NAME.as_str()
                                                        },
                                                    ],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::SPAN,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let mut interest = ::tracing::subscriber::Interest::never();
                                    if tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            interest = __CALLSITE.interest();
                                            !interest.is_never()
                                        }
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                    {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Span::new(
                                            meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                meta.fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"wasi:websocket/handler@0.1.0"
                                                                    as &dyn ::tracing::field::Value,
                                                            )),
                                                            (::tracing::__macro_support::Option::Some(
                                                                &"handle" as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            },
                                        )
                                    } else {
                                        let span = ::tracing::__macro_support::__disabled_span(
                                            __CALLSITE.metadata(),
                                        );
                                        {};
                                        span
                                    }
                                };
                                let callee = unsafe {
                                    wasmtime::component::TypedFunc::<
                                        (wasmtime::component::Resource<Event>,),
                                        (Result<(), Error>,),
                                    >::new_unchecked(self.handle)
                                };
                                let ((ret0,), _) = callee
                                    .call_concurrent(accessor, (arg0,))
                                    .instrument(span.clone())
                                    .await?;
                                Ok(ret0)
                            }
                        }
                    }
                }
            }
        }
        const _: &str = "package credibil:wasi-websocket;\n\nworld websocket {\n    include wasi:websocket/duplex@0.1.0;\n}";
        const _: &str = "package wasi:websocket@0.1.0;\n\nworld imports {\n    import types;\n    import client;\n}\n\nworld sender {\n    include imports;\n}\n\nworld duplex {\n    include imports;\n    export handler;\n}\n\ninterface types {\n    /// A connection to a websocket service.\n    resource socket {\n        connect: static async func(name: string) -> result<socket, error>;\n        disconnect: func() -> result<_, error>;\n    }\n\n    /// A type alias for string to represent a websocket group\n    type group = string;\n\n    /// A websocket event.\n    resource event {\n        constructor(data: list<u8>);\n        /// The group this event was received on, if any\n        group: func() -> option<group>;\n        /// The event message.\n        data: func() -> list<u8>;\n    }\n\n    /// Errors that can occur when using the websocket interface.\n    variant error {\n        /// The request or operation timed out.\n        timeout,\n        /// An error occurred with the connection.\n        connection(string),\n        /// A permission error occurred.\n        permission-denied(string),\n        /// A catch all for other types of errors\n        other(string),\n    }\n}\n\ninterface client {\n    use types.{error, event, socket, group};\n\n    /// Sends the event using the given socket.\n    send: async func(s: borrow<socket>, event: event, group: option<list<group>>) -> result<_, error>;\n}\n\ninterface handler {\n    use types.{event, error};\n\n    /// Whenever this guest receives a message in one of the subscribed topics, the message is\n    /// sent to this handler. The guest is responsible for matching on the group and handling the\n    /// message accordingly. Implementors (such as hosts) calling this interface should make their\n    /// own decisions on how to handle errors returned from this function.\n    handle: async func(event: event) -> result<_, error>;\n}\n\n\n\n";
    }
    use std::fmt::Debug;
    use std::sync::Arc;
    pub use qwasr::FutureResult;
    use qwasr::{Host, Server, State};
    use wasmtime::component::{HasData, Linker};
    use wasmtime_wasi::{ResourceTable, ResourceTableError};
    pub use self::default_impl::WebSocketDefault;
    pub use self::generated::Websocket;
    pub use self::generated::wasi::websocket::types::Error;
    use self::generated::wasi::websocket::{client, types as generated_types};
    pub use self::resource::*;
    /// Result type for WebSocket operations.
    pub type Result<T, E = Error> = anyhow::Result<T, E>;
    /// Host-side service for `wasi:websocket`.
    pub struct WasiWebSocket;
    #[automatically_derived]
    impl ::core::clone::Clone for WasiWebSocket {
        #[inline]
        fn clone(&self) -> WasiWebSocket {
            WasiWebSocket
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for WasiWebSocket {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "WasiWebSocket")
        }
    }
    impl HasData for WasiWebSocket {
        type Data<'a> = WasiWebSocketCtxView<'a>;
    }
    impl<T> Host<T> for WasiWebSocket
    where
        T: WebSocketView + 'static,
    {
        fn add_to_linker(linker: &mut Linker<T>) -> anyhow::Result<()> {
            client::add_to_linker::<_, Self>(linker, T::websocket)?;
            Ok(generated_types::add_to_linker::<_, Self>(linker, T::websocket)?)
        }
    }
    impl<S> Server<S> for WasiWebSocket
    where
        S: State,
        S::StoreCtx: WebSocketView,
    {
        async fn run(&self, state: &S) -> anyhow::Result<()> {
            server::run(state).await
        }
    }
    /// A trait which provides internal WASI WebSocket state.
    ///
    /// This is implemented by the `T` in `Linker<T>`  a single type shared across
    /// all WASI components for the runtime build.
    pub trait WebSocketView: Send {
        /// Return a [`WasiWebSocketCtxView`] from mutable reference to self.
        fn websocket(&mut self) -> WasiWebSocketCtxView<'_>;
    }
    /// View into [`WebSocketCtx`] implementation and [`ResourceTable`].
    pub struct WasiWebSocketCtxView<'a> {
        /// Mutable reference to the WASI WebSocket context.
        pub ctx: &'a mut dyn WebSocketCtx,
        /// Mutable reference to table used to manage resources.
        pub table: &'a mut ResourceTable,
    }
    /// A trait which provides internal WASI WebSocket context.
    ///
    /// This is implemented by the resource-specific provider of WebSocket
    /// functionality.
    pub trait WebSocketCtx: Debug + Send + Sync + 'static {
        /// Connect to the WebSocket service and return a socket.
        ///
        /// # Errors
        ///
        /// Returns an error if the connection fails.
        fn connect(&self) -> FutureResult<Arc<dyn Socket>>;
        /// Create a new event with the given payload.
        ///
        /// # Errors
        ///
        /// Returns an error if event creation fails.
        fn new_event(&self, data: Vec<u8>) -> anyhow::Result<Arc<dyn Event>>;
    }
    /// `anyhow::Error` to `Error` mapping
    impl From<anyhow::Error> for Error {
        fn from(err: anyhow::Error) -> Self {
            Self::Other(err.to_string())
        }
    }
    /// `ResourceTableError` to `Error` mapping
    impl From<ResourceTableError> for Error {
        fn from(err: ResourceTableError) -> Self {
            Self::Other(err.to_string())
        }
    }
    /// `wasmtime::Error` to `Error` mapping
    impl From<wasmtime::Error> for Error {
        fn from(err: wasmtime::Error) -> Self {
            Self::Other(err.to_string())
        }
    }
}
pub use host::*;
